p8105_hw1_ym3077
================

## Problem 1

Load the libraries and dataset:

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.2     ✔ tibble    3.3.0
    ## ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
    ## ✔ purrr     1.1.0     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(moderndive)

data("early_january_weather")
```

Dataset Description:

``` r
names(early_january_weather)
```

    ##  [1] "origin"     "year"       "month"      "day"        "hour"      
    ##  [6] "temp"       "dewp"       "humid"      "wind_dir"   "wind_speed"
    ## [11] "wind_gust"  "precip"     "pressure"   "visib"      "time_hour"

``` r
early_january_weather
```

    ## # A tibble: 358 × 15
    ##    origin  year month   day  hour  temp  dewp humid wind_dir wind_speed
    ##    <chr>  <int> <int> <int> <int> <dbl> <dbl> <dbl>    <dbl>      <dbl>
    ##  1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 
    ##  2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06
    ##  3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 
    ##  4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 
    ##  5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 
    ##  6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 
    ##  7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 
    ##  8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 
    ##  9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 
    ## 10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 
    ## # ℹ 348 more rows
    ## # ℹ 5 more variables: wind_gust <dbl>, precip <dbl>, pressure <dbl>,
    ## #   visib <dbl>, time_hour <dttm>

``` r
nrow(early_january_weather)
```

    ## [1] 358

``` r
ncol(early_january_weather)
```

    ## [1] 15

``` r
mean_temp = mean(early_january_weather$temp)
mean_temp
```

    ## [1] 39.58212

The `early_january_weather` dataset contains variable: origin, year,
month, day, hour, temp, dewp, humid, wind_dir, wind_speed, wind_gust,
precip, pressure, visib, time_hour; and has 358 rows and 15 columns.

The mean temperature is 39.5821229 °F.

Make Scatterplot:

``` r
weather_plot = ggplot(early_january_weather, aes(x = time_hour, y = temp, 
                                                 color = humid)) + geom_point()
weather_plot
```

![](p8105_hw1_ym3077_files/figure-gfm/unnamed-chunk-3-1.png)<!-- -->

This weather scatterplot shows how temperature fluctuates every day, and
there is an independent pattern of humidity, as low humidity periods
occuring at both cold and warm temperature.

Export the scatterplot:

``` r
ggsave("weather_plot.png", plot = weather_plot, height = 4, width = 6)
```

## Problem 2

Create dataframe:

``` r
hw1_df = tibble(
  random_sample = rnorm(10),
  vec_logical = rnorm(10) > 0,
  vec_character = c("Here", "is", "my", "data", "science", "one", "home", "work", "one", "answer"),
  vec_factor = factor(sample(c("A", "B", "C"), size = 10, replace = TRUE))
)
hw1_df
```

    ## # A tibble: 10 × 4
    ##    random_sample vec_logical vec_character vec_factor
    ##            <dbl> <lgl>       <chr>         <fct>     
    ##  1         1.01  FALSE       Here          A         
    ##  2        -0.998 TRUE        is            C         
    ##  3        -0.700 FALSE       my            A         
    ##  4         0.821 TRUE        data          B         
    ##  5        -0.723 TRUE        science       A         
    ##  6         0.831 TRUE        one           B         
    ##  7         1.05  FALSE       home          B         
    ##  8        -1.14  FALSE       work          B         
    ##  9        -0.890 TRUE        one           A         
    ## 10         0.249 FALSE       answer        B

Take the mean of each variable:

``` r
mean(hw1_df$random_sample)     
```

    ## [1] -0.04933635

``` r
mean(hw1_df$vec_logical)        
```

    ## [1] 0.5

``` r
mean(hw1_df$vec_character)
```

    ## Warning in mean.default(hw1_df$vec_character): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

``` r
mean(hw1_df$vec_factor) 
```

    ## Warning in mean.default(hw1_df$vec_factor): argument is not numeric or logical:
    ## returning NA

    ## [1] NA

We can take mean for the random sample and the logic vector, but not for
character vector or factor factor.

Convert to numeric:

``` r
as.numeric(hw1_df$vec_logical)
as.numeric(hw1_df$vec_character)
```

    ## Warning: NAs introduced by coercion

``` r
as.numeric(hw1_df$vec_factor)
```

The **logical vector** is coerced to `1`s and `0`s, where `TRUE` becomes
`1`, `FALSE` becomes `0`. This explains why taking the mean of a logical
vector works: it returns the proportion of TRUE values.

The **character vector** cannot be meaningfully coerced to numbers. R
returns all `NA`s with a warning. This explains why `mean()` fails for
character data — it’s not numeric.

The **factor vector** is coerced to its underlying integer levels, based
on the order of factor levels (e.g., “A” = 1, “B” = 2, “C” = 3 by
default). This gives numeric values, and explains why `mean()` success.

So, this coercion behavior helps explain which variables can be averaged
using `mean()`, and why others cannot with errors.
